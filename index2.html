```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Probability Minesweeper</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Inter font -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <!-- Tailwind CSS (browser build) -->
  <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
  <!-- Fallback CDN (in case the browser build fails) -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-900 text-gray-200 flex flex-col h-screen" style="font-family: 'Inter', sans-serif;">
  <!-- Header & Controls -->
  <div class="flex flex-col items-center p-4 space-y-2">
    <h1 class="text-2xl font-bold">Probability Minesweeper</h1>
    <div class="flex flex-wrap gap-3 items-center justify-center">
      <label class="flex items-center space-x-1">
        <span class="text-sm">Rows:</span>
        <input id="rowsInput" type="number" min="5" max="30" value="10"
               class="w-16 p-1 border rounded bg-gray-800 text-white focus:outline-none focus:ring-2 focus:ring-blue-500"/>
      </label>
      <label class="flex items-center space-x-1">
        <span class="text-sm">Cols:</span>
        <input id="colsInput" type="number" min="5" max="30" value="10"
               class="w-16 p-1 border rounded bg-gray-800 text-white focus:outline-none focus:ring-2 focus:ring-blue-500"/>
      </label>
      <label class="flex items-center space-x-1">
        <span class="text-sm">Complexity:</span>
        <select id="complexitySelect"
                class="p-1 border rounded bg-gray-800 text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
          <option value="0.1">Easy (10%)</option>
          <option value="0.15" selected>Medium (15%)</option>
          <option value="0.2">Hard (20%)</option>
          <option value="custom">Custom</option>
        </select>
      </label>
      <label id="customProbLabel" class="flex items-center space-x-1 hidden">
        <span class="text-sm">Bomb %:</span>
        <input id="bombProbInput" type="number" min="1" max="90" value="15"
               class="w-16 p-1 border rounded bg-gray-800 text-white focus:outline-none focus:ring-2 focus:ring-blue-500"/>
      </label>
      <button id="restartBtn"
              class="flex items-center space-x-1 bg-gray-700 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded focus:outline-none focus:ring-2 focus:ring-blue-500">
        <img src="https://unpkg.com/lucide-static@latest/icons/reload.svg" class="w-5 h-5"/>
        <span>Restart</span>
      </button>
    </div>
    <div id="message" class="mt-2 text-sm text-center text-yellow-300 min-h-5"></div>
  </div>

  <!-- Game container (scrollable) -->
  <div id="gameContainer" class="flex-1 w-full overflow-auto p-2">
    <div id="game" class="grid gap-0.5 mx-auto"></div>
  </div>

  <script>
    // ==================== Configuration ====================
    // Default values (will be overridden by UI inputs)
    let ROWS = 10;
    let COLS = 10;
    let BOMB_PROB = 0.15; // 15% default

    // ==================== Game State ====================
    let board = [];          // 2â€‘D array of cells
    let revealedCount = 0;   // number of revealed safe cells
    let totalSafe = 0;       // total safe cells (computed after board generation)
    let gameOver = false;

    // ==================== Helper Functions ====================
    const inBounds = (r, c) => r >= 0 && r < ROWS && c >= 0 && c < COLS;

    const countAdjacentBombs = (r, c) => {
      let count = 0;
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          const nr = r + dr, nc = c + dc;
          if (inBounds(nr, nc) && board[nr][nc].bomb) count++;
        }
      }
      return count;
    };

    const floodFill = (r, c) => {
      const stack = [[r, c]];
      while (stack.length) {
        const [cr, cc] = stack.pop();
        const cell = board[cr][cc];
        if (cell.revealed) continue;
        cell.revealed = true;
        revealedCount++;
        const el = document.getElementById(`cell-${cr}-${cc}`);
        el.classList.add('bg-gray-800', 'text-gray-200', 'cursor-default');
        if (cell.adjacent) {
          el.textContent = cell.adjacent;
        }
        // Expand if no adjacent bombs
        if (cell.adjacent === 0) {
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              const nr = cr + dr, nc = cc + dc;
              if (inBounds(nr, nc) && !board[nr][nc].bomb && !board[nr][nc].revealed) {
                stack.push([nr, nc]);
              }
            }
          }
        }
      }
    };

    const revealAllBombs = () => {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cell = board[r][c];
          if (cell.bomb) {
            const el = document.getElementById(`cell-${r}-${c}`);
            el.classList.add('bg-red-800', 'text-white', 'cursor-default');
            el.innerHTML = '<img src="https://unpkg.com/lucide-static@latest/icons/bomb.svg" class="w-5 h-5"/>';
          }
        }
      }
    };

    const showMessage = (msg) => {
      document.getElementById('message').textContent = msg;
    };

    // ==================== UI Rendering ====================
    const renderBoard = () => {
      const gameDiv = document.getElementById('game');
      // Set dynamic grid dimensions
      gameDiv.style.gridTemplateColumns = `repeat(${COLS}, 2.5rem)`;
      gameDiv.style.gridTemplateRows = `repeat(${ROWS}, 2.5rem)`;
      gameDiv.innerHTML = ''; // clear previous cells

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cellDiv = document.createElement('div');
          cellDiv.id = `cell-${r}-${c}`;
          cellDiv.className = 'w-10 h-10 flex items-center justify-center text-xs cursor-pointer select-none rounded bg-gray-600';
          cellDiv.dataset.row = r;
          cellDiv.dataset.col = c;
          cellDiv.addEventListener('click', onCellClick);
          gameDiv.appendChild(cellDiv);
        }
      }
    };

    // ==================== Event Handlers ====================
    const onCellClick = (e) => {
      if (gameOver) return;
      const r = Number(e.currentTarget.dataset.row);
      const c = Number(e.currentTarget.dataset.col);
      const cell = board[r][c];
      if (cell.revealed) return;
      if (cell.bomb) {
        // Reveal bomb and end game
        e.currentTarget.classList.add('bg-red-800', 'text-white', 'cursor-default');
        e.currentTarget.innerHTML = '<img src="https://unpkg.com/lucide-static@latest/icons/bomb.svg" class="w-5 h-5"/>';
        gameOver = true;
        showMessage('ðŸ’¥ You hit a bomb! Game over.');
        revealAllBombs();
      } else {
        // Safe cell: reveal and possibly floodâ€‘fill
        floodFill(r, c);
        if (revealedCount === totalSafe) {
          gameOver = true;
          showMessage('ðŸŽ‰ Congratulations! You cleared the board.');
          revealAllBombs(); // optional: show remaining bombs
        }
      }
    };

    // ==================== Game Initialization ====================
    const initGame = () => {
      // Read UI values
      ROWS = Math.max(5, Math.min(30, Number(document.getElementById('rowsInput').value)));
      COLS = Math.max(5, Math.min(30, Number(document.getElementById('colsInput').value)));
      const complexity = document.getElementById('complexitySelect').value;
      if (complexity === 'custom') {
        BOMB_PROB = Math.min(0.9, Math.max(0.01, Number(document.getElementById('bombProbInput').value) / 100));
      } else {
        BOMB_PROB = parseFloat(complexity);
      }

      board = [];
      revealedCount = 0;
      gameOver = false;
      showMessage('');

      // Generate board with random bombs
      for (let r = 0; r < ROWS; r++) {
        const row = [];
        for (let c = 0; c < COLS; c++) {
          const bomb = Math.random() < BOMB_PROB;
          row.push({ bomb, revealed: false, adjacent: 0 });
        }
        board.push(row);
      }

      // Compute adjacent bomb counts
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (!board[r][c].bomb) {
            board[r][c].adjacent = countAdjacentBombs(r, c);
          }
        }
      }

      // Count total safe cells for win detection
      totalSafe = board.flat().filter(cell => !cell.bomb).length;

      renderBoard();
    };

    // ==================== UI Interaction ====================
    document.getElementById('restartBtn').addEventListener('click', initGame);

    // Show/hide custom probability input
    document.getElementById('complexitySelect').addEventListener('change', (e) => {
      const customLabel = document.getElementById('customProbLabel');
      if (e.target.value === 'custom') {
        customLabel.classList.remove('hidden');
      } else {
        customLabel.classList.add('hidden');
      }
    });

    // Initial game start
    initGame();
  </script>
</body>
</html>
```
