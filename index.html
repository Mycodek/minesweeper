<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Probability Minesweeper</title>
  <!-- Retro pixelâ€‘style font -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    /* Global layout */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Press Start 2P', monospace;
      background: #1a1a1a;
      color: #e0e0e0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
    }
    h1 { margin: 1rem 0; font-size: 1.5rem; }

    /* Game container */
    #game {
      display: grid;
      gap: 2px;
      background: #333;
      padding: 2px;
      border: 4px solid #555;
      border-radius: 8px;
      /* Prevent CLS by fixing size based on default grid */
      width: fit-content;
    }

    /* Individual cells */
    .cell {
      width: 32px;
      height: 32px;
      background: #555;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.6rem;
      cursor: pointer;
      user-select: none;
      border-radius: 4px;
      transition: background 0.2s;
    }
    .cell.revealed { background: #222; cursor: default; }
    .cell.bomb { background: #b00; color: #fff; }
    .cell.safe-0 { background: #222; }
    .cell.safe-1 { background: #2a2a2a; }
    .cell.safe-2 { background: #242424; }
    .cell.safe-3 { background: #1e1e1e; }
    .cell.safe-4 { background: #181818; }
    .cell.safe-5 { background: #121212; }
    .cell.safe-6 { background: #0c0c0c; }
    .cell.safe-7 { background: #060606; }
    .cell.safe-8 { background: #000; }

    /* Controls */
    #controls {
      margin: 1rem 0;
      display: flex;
      gap: 1rem;
    }
    button {
      padding: 0.5rem 1rem;
      font-family: inherit;
      font-size: 0.6rem;
      background: #444;
      color: #e0e0e0;
      border: 2px solid #777;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s, border-color 0.2s;
    }
    button:hover { background: #555; border-color: #aaa; }

    /* Message area */
    #message {
      margin-top: 0.5rem;
      font-size: 0.8rem;
      min-height: 1.2rem;
    }
  </style>
</head>
<body>
  <h1>Probability Minesweeper</h1>

  <div id="controls">
    <button id="restartBtn">Restart</button>
    <!-- You can add more controls (e.g., difficulty) here -->
  </div>

  <div id="game"></div>

  <div id="message"></div>

  <script>
    // ---------- Configuration ----------
    const ROWS = 10;               // number of rows
    const COLS = 10;               // number of columns
    const BOMB_PROB = 0.15;        // probability a cell contains a bomb (15%)

    // ---------- Game State ----------
    let board = [];                // 2â€‘D array of cell objects
    let revealedCount = 0;         // number of revealed safe cells
    let totalSafe;                // total safe cells (computed after board generation)
    let gameOver = false;

    // ---------- Helper Functions ----------
    // Returns true if (r,c) is inside the board
    const inBounds = (r, c) => r >= 0 && r < ROWS && c >= 0 && c < COLS;

    // Count bombs around a given cell
    const countAdjacentBombs = (r, c) => {
      let count = 0;
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          const nr = r + dr, nc = c + dc;
          if (inBounds(nr, nc) && board[nr][nc].bomb) count++;
        }
      }
      return count;
    };

    // Floodâ€‘fill algorithm: reveal all connected safe cells with 0 adjacent bombs
    const floodFill = (r, c) => {
      const stack = [[r, c]];
      while (stack.length) {
        const [cr, cc] = stack.pop();
        const cell = board[cr][cc];
        if (cell.revealed) continue;
        cell.revealed = true;
        revealedCount++;
        const el = document.getElementById(`cell-${cr}-${cc}`);
        el.classList.add('revealed', `safe-${cell.adjacent}`);
        el.textContent = cell.adjacent ? cell.adjacent : '';
        // If this cell has no neighboring bombs, continue expanding
        if (cell.adjacent === 0) {
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              const nr = cr + dr, nc = cc + dc;
              if (inBounds(nr, nc) && !board[nr][nc].bomb && !board[nr][nc].revealed) {
                stack.push([nr, nc]);
              }
            }
          }
        }
      }
    };

    // ---------- UI Rendering ----------
    const renderBoard = () => {
      const gameDiv = document.getElementById('game');
      // Set CSS grid dimensions
      gameDiv.style.gridTemplateRows = `repeat(${ROWS}, 32px)`;
      gameDiv.style.gridTemplateColumns = `repeat(${COLS}, 32px)`;
      gameDiv.innerHTML = ''; // clear previous cells

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cellDiv = document.createElement('div');
          cellDiv.id = `cell-${r}-${c}`;
          cellDiv.className = 'cell';
          cellDiv.dataset.row = r;
          cellDiv.dataset.col = c;
          cellDiv.addEventListener('click', onCellClick);
          gameDiv.appendChild(cellDiv);
        }
      }
    };

    // ---------- Event Handlers ----------
    const onCellClick = (e) => {
      if (gameOver) return;
      const r = Number(e.currentTarget.dataset.row);
      const c = Number(e.currentTarget.dataset.col);
      const cell = board[r][c];
      if (cell.revealed) return;

      if (cell.bomb) {
        // Reveal bomb and end game
        e.currentTarget.classList.add('bomb', 'revealed');
        e.currentTarget.textContent = 'ðŸ’£';
        gameOver = true;
        showMessage('ðŸ’¥ You hit a bomb! Game over.');
        revealAllBombs();
      } else {
        // Safe cell: reveal and possibly floodâ€‘fill
        floodFill(r, c);
        if (revealedCount === totalSafe) {
          gameOver = true;
          showMessage('ðŸŽ‰ Congratulations! You cleared the board.');
          revealAllBombs(); // optional: show remaining bombs
        }
      }
    };

    const revealAllBombs = () => {
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cell = board[r][c];
          if (cell.bomb) {
            const el = document.getElementById(`cell-${r}-${c}`);
            el.classList.add('bomb', 'revealed');
            el.textContent = 'ðŸ’£';
          }
        }
      }
    };

    const showMessage = (msg) => {
      document.getElementById('message').textContent = msg;
    };

    // ---------- Game Initialization ----------
    const initGame = () => {
      board = [];
      revealedCount = 0;
      gameOver = false;
      showMessage('');
      // Create board with random bombs
      for (let r = 0; r < ROWS; r++) {
        const row = [];
        for (let c = 0; c < COLS; c++) {
          const bomb = Math.random() < BOMB_PROB;
          row.push({ bomb, revealed: false, adjacent: 0 });
        }
        board.push(row);
      }
      // Compute adjacent bomb counts
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (!board[r][c].bomb) {
            board[r][c].adjacent = countAdjacentBombs(r, c);
          }
        }
      }
      // Count total safe cells for win detection
      totalSafe = board.flat().filter(cell => !cell.bomb).length;
      renderBoard();
    };

    // ---------- Controls ----------
    document.getElementById('restartBtn').addEventListener('click', initGame);

    // Start first game on load
    initGame();
  </script>
</body>
</html>
